package game

import (
	"fmt"
	"time"

	"github.com/suvrick/go-kiss-core/packets/client"
	"github.com/suvrick/go-kiss-core/packets/server"
	"github.com/suvrick/go-kiss-core/socket"
	"github.com/suvrick/go-kiss-core/types"
)

const Tototo93 types.I = 22132982

type Bot struct {
	SelfID          types.I
	Result          server.LoginResultType
	Balance         types.I
	CanCollect      types.B
	BonusDay        types.B
	CollectionPoint types.I

	Player
}

type Player struct {
	PlayerID   types.I
	Name       types.S
	Avatar     types.S
	Profile    types.S
	Sex        types.B
	Vip        types.B
	Kissed     types.I
	KissedDay  types.I
	KissedRoom types.I
}

type Room struct {
	RoomID           types.I
	LeaderID         types.I
	RollerID         types.I
	KissAnswerLeader server.KissAnswer
	KissAnswerRoller server.KissAnswer
	Players          map[types.I]*Player
}

type Game struct {
	ws                *socket.Socket
	self              *Bot
	gameOver          chan struct{}
	closeRole         CloseRole
	b                 uint8
	timeoutRollBottle int
	timeoutKiss       int
	room              *Room

	updateSelfHandler func(self Bot)
	updateRoomHandler func(room Room)
}

func NewGame() *Game {
	g := Game{
		timeoutRollBottle: 5,
		timeoutKiss:       5,
		self: &Bot{
			Player: Player{},
		},
		room: &Room{
			Players: make(map[types.I]*Player),
		},
	}
	return &g
}

func (g *Game) Connection() error {

	g.closeRole = FAST
	g.gameOver = make(chan struct{})

	ws := socket.NewSocket(socket.GetDefaultSocketConfig())
	ws.SetOpenHandler(g.openHandler)
	ws.SetErrorHandler(g.errorHandler)
	ws.SetReadHandler(g.readHandler)
	ws.SetCloseHandler(g.closeHandler)

	if err := ws.Connection(); err != nil {
		return err
	}

	g.ws = ws
	g.b = 7 // 0x00000111

	return nil
}

func (g *Game) Send(packetID client.PacketClientType, packet interface{}) {
	if g.ws != nil {
		g.ws.Send(packetID, packet)
	}
}

func (g *Game) Login(packet interface{}) {
	if g.ws != nil {
		g.ws.Send(client.LOGIN, packet)
	}
}

func (g *Game) GoRoom(roomID types.B) {
	if g.ws != nil {
		g.closeRole = NEVER
		g.ws.Send(client.BOTTLE_PLAY, &client.BottlePlay{
			RoomID: roomID,
		})
	}
}

func (g *Game) GoRoomToPlayer(playerID types.I) {
	if g.ws != nil {
		g.closeRole = NEVER
		g.ws.Send(client.MOVE, &client.Move{
			PlayerID:  playerID,
			ByteField: 0,
		})
	}
}

func (g *Game) GameOver() chan struct{} {
	return g.gameOver
}

func (g *Game) errorHandler(game *socket.Socket, err error) {
	game.Log(fmt.Sprintf("[error] %v", err.Error()))
	game.Close()
}

func (g *Game) readHandler(ws *socket.Socket, ID server.PacketServerType, packet interface{}) {

	//ws.Log(fmt.Sprintf("[read] %T %+v", packet, packet))

	switch ID {
	case server.LOGIN:
		p := packet.(*server.Login)
		switch p.Result {
		case server.Success:
			g.self.Result = p.Result
			g.self.SelfID = p.GameID
			g.self.Balance = p.Balance
			g.b &^= 1 // off
		default:
			g.updateSelfEmit()
			g.ws.Close()
		}
	case server.INFO:
		p := packet.(*server.Info)
		player := &Player{}

		if len(p.Players) > 0 {
			player.PlayerID = p.Players[0].GameID
			player.Name = p.Players[0].Name
			player.Avatar = p.Players[0].Avatar.Avatar
			player.Profile = p.Players[0].Profile
			player.Sex = p.Players[0].Sex
			player.Vip = p.Players[0].Vip
			player.Kissed = p.Players[0].Kisses.Kissed
			player.KissedDay = p.Players[0].Kisses.KissedDay
		}

		for _, v := range g.room.Players {
			if v.PlayerID == player.PlayerID {
				g.room.Players[player.PlayerID] = player
				g.updateRoomEmit()
			}
		}

		if g.self.SelfID == player.PlayerID {
			g.self.Player = *player
			g.updateSelfEmit()
			g.b &^= 4 //off
		}
	case server.BONUS:
		p := packet.(*server.Bonus)
		g.self.CanCollect = p.CanCollect
		g.self.BonusDay = p.Day

		if p.CanCollect == 1 {
			ws.Send(client.BONUS, &client.Bonus{})
		}
	case server.REWARDS:
		p := packet.(*server.Rewards)
		for _, reward := range g.getRewards(p.Rewards) {
			if reward.Count > 0 {
				g.b |= 2 // on
				ws.Send(client.GAME_REWARDS_GET, &client.GameRewardsGet{
					RewardID: reward.ID,
				})
				return
			}
		}

		if (g.b & 4) == 4 {
			ws.Send(client.REQUEST, &client.Request{
				Players: []types.I{g.self.SelfID},
				Mask:    server.INFOMASK,
			})
		}

		g.b &^= 2 // off

	case server.BOTTLE_ROOM:
		p := packet.(*server.BottleRoom)
		g.room.RoomID = p.RoomID
		for _, v := range p.Players {
			if v != 0 {

				g.room.Players[v] = &Player{
					PlayerID: v,
				}

				ws.Send(client.REQUEST, &client.Request{
					Players: []types.I{v},
					Mask:    server.INFOMASK,
				})
			}
		}

		g.updateRoomEmit()
	case server.BOTTLE_JOIN:
		p := packet.(*server.BottleJoin)

		g.room.Players[p.PlayerID] = &Player{
			PlayerID: p.PlayerID,
		}

		ws.Send(client.REQUEST, &client.Request{
			Players: []types.I{p.PlayerID},
			Mask:    server.INFOMASK,
		})

		g.updateRoomEmit()
	case server.BOTTLE_LEADER:
		p := packet.(*server.BottleLeader)
		g.room.LeaderID = p.LeaderID
		if p.LeaderID == g.self.SelfID {
			go func() {
				ws.Log("I am leader!")
				<-time.After(time.Second * time.Duration(g.timeoutRollBottle))
				ws.Log("I am rolled bottle!")
				ws.Send(client.BOTTLE_ROLL, &client.BottleRoll{
					IntField: 0,
				})
			}()
		}

		g.updateRoomEmit()
	case server.BOTTLE_ROLL:
		p := packet.(*server.BottleRoll)
		g.room.LeaderID = p.LeaderID
		g.room.RollerID = p.RollerID
		if p.LeaderID == g.self.SelfID || p.RollerID == g.self.SelfID {
			go func() {
				if p.RollerID == g.self.SelfID {
					ws.Log("I am kissed as roller!")
				} else {
					ws.Log("I am kissed as leader!")
				}

				<-time.After(time.Second * time.Duration(g.timeoutKiss))

				ws.Send(client.BOTTLE_KISS, &client.BottleKiss{
					Answer: 1,
				})
			}()
		}
		// 3.2 MB
		g.updateRoomEmit()
	case server.BOTTLE_KISS:
		p := packet.(*server.BottleKiss)
		if p.PlayerID == g.room.LeaderID {
			g.room.KissAnswerLeader = p.Answer
		} else if p.PlayerID == g.room.RollerID {
			g.room.KissAnswerRoller = p.Answer
		}

		if currentPlayer, ok := g.room.Players[p.PlayerID]; ok {
			if p.Answer == 1 {
				currentPlayer.KissedRoom += 1
				currentPlayer.KissedDay += 1
				currentPlayer.Kissed += 1
			}
		}

		g.updateRoomEmit()
	case server.BOTTLE_LEAVE:
		p := packet.(*server.BottleLeave)
		delete(g.room.Players, p.PlayerID)
		g.updateRoomEmit()
	}

	if g.b == 0 && g.closeRole == FAST {
		go func() {
			<-time.After(time.Millisecond * 500)
			g.ws.Close()
		}()
	}
}

func (g *Game) SetUpdateSelf(fn func(self Bot)) {
	g.updateSelfHandler = fn
}

func (g *Game) SetUpdateRoom(fn func(room Room)) {
	g.updateRoomHandler = fn
}

func (g *Game) updateSelfEmit() {
	if g.self != nil && g.updateSelfHandler != nil {
		g.updateSelfHandler(*g.self)
	}
}

func (g *Game) updateRoomEmit() {
	if g.room != nil && g.updateRoomHandler != nil {
		g.updateRoomHandler(*g.room)
	}
}

func (g *Game) getRewards(r []server.Reward) (rewards []server.Reward) {
	for _, v := range r {
		if v.ID > 0 && v.Count > 0 {
			rewards = append(rewards, v)
		}
	}
	return
}

func (g *Game) openHandler(game *socket.Socket) {
	game.Log("[open] game socket open")
}

func (g *Game) closeHandler(game *socket.Socket, rule byte, caption string) {
	game.Log(fmt.Sprintf("[close] game socket close by %s", caption))
	close(g.gameOver)
}

type CloseRole uint8

const (
	FAST  CloseRole = 0
	NEVER CloseRole = 1
)
